<!DOCTYPE html>
<html lang="en" data-theme="dark">

<head>
    <meta charset="UTF-8">
    <meta
        http-equiv="X-UA-Compatible"
        content="IE=edge"
    >
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0"
    >
    <title>Scrum Poker - Agile Scrum Estimation Tool</title>
    <meta
        name="description"
        content="Engage in interactive, fun, and effective Scrum planning with our free online Agile Scrum Master Game. Perfect for remote teams, this tool simplifies your Agile estimation and planning process."
    >
    <meta
        name="keywords"
        content="Scrum Game, Agile Planning Tool, Free Scrum Master Game, Online Estimation Tool, Agile Project Management, Scrum Planning Poker, Agile Collaboration Tool"
    >
    <meta
        name="author"
        content="Hakan SARIER"
    >

    <!-- Open Graph / Facebook -->
    <meta
        property="og:type"
        content="website"
    >
    <meta
        property="og:url"
        content="https://scrum-oiyf.onrender.com/"
    >
    <meta
        property="og:title"
        content="Agile Scrum Master Game - Free Online Collaborative Tool"
    >
    <meta
        property="og:description"
        content="Interactive and engaging Scrum planning tool for Agile teams. Simplify your estimation process with our free online game."
    >
    <!-- <meta property="og:image" content="https://scrum-oiyf.onrender.com/image.jpg"> -->

    <!-- Twitter -->
    <meta
        property="twitter:card"
        content="summary_large_image"
    >
    <meta
        property="twitter:url"
        content="https://scrum-oiyf.onrender.com/"
    >
    <meta
        property="twitter:title"
        content="Agile Scrum Master Game - Free Online Collaborative Tool"
    >
    <meta
        property="twitter:description"
        content="Interactive and engaging Scrum planning tool for Agile teams. Simplify your estimation process with our free online game."
    >
    <!-- <meta property="twitter:image" content="https://scrum-oiyf.onrender.com/image.jpg"> -->

    <!-- Favicon -->
    <link
        rel="icon"
        type="image/x-icon"
        href="favicon.png"
    >
    <link
        rel="stylesheet"
        href="index.css"
    >
    <script src="/socket.io/socket.io.js"></script>
    <script>

        let socket = io.connect('/');
        let currentRoom;
        let isMaster = false;
        let userName = '';
        let selectedAvatar = '👤'; // Default avatar
        let votesRevealed = false; // Track if votes are currently revealed
        const SESSION_DURATION = 6 * 60 * 60 * 1000; // 6 saat

        // Audio setup for mobile browser support
        let notificationAudio = null;
        let audioUnlocked = false;

        // Theme toggle functionality
        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            const themeIcon = document.getElementById('themeIcon');

            html.setAttribute('data-theme', newTheme);
            themeIcon.textContent = newTheme === 'dark' ? '🌙' : '☀️';

            localStorage.setItem('theme', newTheme);
        }

        // Load saved theme (default to dark)
        window.addEventListener('DOMContentLoaded', () => {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            const themeIcon = document.getElementById('themeIcon');

            document.documentElement.setAttribute('data-theme', savedTheme);
            if (themeIcon) {
                themeIcon.textContent = savedTheme === 'dark' ? '🌙' : '☀️';
            }

            // Setup avatar selection
            document.querySelectorAll('.avatar-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('.avatar-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    this.classList.add('selected');
                    const radio = this.querySelector('input[type="radio"]');
                    if (radio) {
                        radio.checked = true;
                        selectedAvatar = radio.value;
                    }
                });
            });
        });

        // LocalStorage'dan session bilgilerini al
        function loadSession() {
            try {
                const sessionData = localStorage.getItem('scrumSession');
                if (sessionData) {
                    const session = JSON.parse(sessionData);
                    const now = Date.now();

                    // 6 saat içindeyse otomatik geri katıl
                    if (now - session.timestamp < SESSION_DURATION) {
                        document.getElementById('username').value = session.name;
                        document.getElementById('room').value = session.room;
                        document.getElementById('isMaster').checked = session.isMaster;

                        // Restore avatar selection
                        if (session.avatar) {
                            selectedAvatar = session.avatar;
                            // Update UI to show selected avatar
                            document.querySelectorAll('.avatar-option').forEach(opt => {
                                opt.classList.remove('selected');
                                const radio = opt.querySelector('input[type="radio"]');
                                if (radio && radio.value === session.avatar) {
                                    opt.classList.add('selected');
                                    radio.checked = true;
                                }
                            });
                        }

                        return session;
                    } else {
                        // Session süresi dolmuş, temizle
                        localStorage.removeItem('scrumSession');
                    }
                }
            } catch (e) {
                console.error('Session yükleme hatası:', e);
            }
            return null;
        }

        // Session bilgilerini kaydet
        function saveSession(room, name, isMaster, avatar) {
            try {
                const sessionData = {
                    room: room,
                    name: name,
                    isMaster: isMaster,
                    avatar: avatar,
                    timestamp: Date.now()
                };
                localStorage.setItem('scrumSession', JSON.stringify(sessionData));
            } catch (e) {
                console.error('Session kaydetme hatası:', e);
            }
        }

        // Update connection status indicator
        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            if (!statusElement) return;

            if (status === 'connected') {
                statusElement.className = 'status-connected';
                statusElement.innerHTML = '🟢 Connected';
            } else if (status === 'reconnecting') {
                statusElement.className = 'status-reconnecting';
                statusElement.innerHTML = '🟡 Reconnecting...';
            } else if (status === 'disconnected') {
                statusElement.className = 'status-disconnected';
                statusElement.innerHTML = '🔴 Disconnected';
            }
        }

        // Otomatik yeniden bağlanma
        socket.on('disconnect', (reason) => {
            console.log('Bağlantı koptu:', reason);

            // Only update connection status if user is in a room
            if (currentRoom) {
                updateConnectionStatus('disconnected');
            }

            // Away durumunu otomatik ayarla
            if (currentRoom) {
                socket.emit('autoAway', { room: currentRoom, isAway: true });
            }

            // Birkaç saniye sonra yeniden bağlanma durumunu göster
            setTimeout(() => {
                if (!socket.connected && currentRoom) {
                    updateConnectionStatus('reconnecting');
                }
            }, 1000);
        });

        socket.on('connect', () => {
            console.log('Bağlantı kuruldu');

            // Only update connection status if user is in a room
            if (currentRoom) {
                updateConnectionStatus('connected');
            }

            // Away durumunu kaldır
            if (currentRoom) {
                socket.emit('autoAway', { room: currentRoom, isAway: false });
            }

            // Eğer daha önce bir odaya katıldıysa, otomatik geri katıl
            const session = loadSession();
            if (session && currentRoom) {
                console.log('Otomatik olarak odaya geri katılınıyor...');
                socket.emit('joinRoom', {
                    room: currentRoom,
                    name: userName,
                    isMaster: isMaster,
                    avatar: selectedAvatar
                });
            }
        });

        socket.on('connect_error', (error) => {
            console.error('Bağlantı hatası:', error);

            // Only update connection status if user is in a room
            if (currentRoom) {
                updateConnectionStatus('reconnecting');
            }
        });

        // Sayfa yüklendiğinde eski session'ı kontrol et
        window.addEventListener('load', () => {
            const session = loadSession();
            if (session) {
                console.log('Önceki session bulundu');
            }
        });

        // Recommended room selection
        function selectRoom(roomName) {
            document.getElementById('room').value = roomName;
        }

        // Toggle What's New modal
        function toggleWhatsNew() {
            const modal = document.getElementById('whatsNewModal');
            if (modal.style.display === 'flex') {
                modal.style.display = 'none';
            } else {
                modal.style.display = 'flex';
            }
        }

        // Toggle Feedback modal
        function toggleFeedback() {
            const modal = document.getElementById('feedbackModal');
            const form = document.getElementById('feedbackForm');
            const success = document.getElementById('feedbackSuccess');
            const submitBtn = document.getElementById('feedbackSubmitBtn');

            if (modal.style.display === 'flex') {
                modal.style.display = 'none';
                // Reset form when closing
                form.reset();
                form.style.display = 'block';
                success.style.display = 'none';

                // Don't reset cooldown when closing - keep it active
                // This prevents spam by closing and reopening
            } else {
                modal.style.display = 'flex';
            }
        }

        // Submit feedback form
        let feedbackCooldownTimer = null;

        async function submitFeedback(event) {
            event.preventDefault();

            const submitBtn = document.getElementById('feedbackSubmitBtn');

            // Check if cooldown is active
            if (submitBtn.disabled) {
                return;
            }

            const rating = document.querySelector('input[name="rating"]:checked').value;
            const email = document.getElementById('feedbackEmail').value;
            const message = document.getElementById('feedbackMessage').value;

            const feedbackData = {
                rating: rating,
                email: email || 'Not provided',
                message: message,
                timestamp: new Date().toISOString(),
                room: currentRoom || 'Not in room'
            };

            try {
                const response = await fetch('/api/feedback', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(feedbackData)
                });

                if (response.ok) {
                    // Show success message
                    document.getElementById('feedbackForm').style.display = 'none';
                    document.getElementById('feedbackSuccess').style.display = 'block';

                    // Start 10-second cooldown
                    startFeedbackCooldown();

                    // Close modal after 2 seconds
                    setTimeout(() => {
                        toggleFeedback();
                    }, 2000);
                } else {
                    alert('Failed to submit feedback. Please try again later.');
                }
            } catch (error) {
                console.error('Error submitting feedback:', error);
                alert('Failed to submit feedback. Please try again later.');
            }
        }

        function startFeedbackCooldown() {
            const submitBtn = document.getElementById('feedbackSubmitBtn');
            let secondsLeft = 10;

            // Disable button
            submitBtn.disabled = true;
            submitBtn.textContent = `Wait ${secondsLeft}s`;

            // Clear any existing timer
            if (feedbackCooldownTimer) {
                clearInterval(feedbackCooldownTimer);
            }

            // Update countdown every second
            feedbackCooldownTimer = setInterval(() => {
                secondsLeft--;

                if (secondsLeft > 0) {
                    submitBtn.textContent = `Wait ${secondsLeft}s`;
                } else {
                    // Re-enable button
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Send Feedback';
                    clearInterval(feedbackCooldownTimer);
                    feedbackCooldownTimer = null;
                }
            }, 1000);
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const whatsNewModal = document.getElementById('whatsNewModal');
            const feedbackModal = document.getElementById('feedbackModal');

            if (event.target === whatsNewModal) {
                whatsNewModal.style.display = 'none';
            }
            if (event.target === feedbackModal) {
                toggleFeedback();
            }
        }

        // Return to login screen
        function returnToLogin() {
            document.getElementById('gameSection').classList.add('d-none');
            document.getElementById('joinSection').style.display = 'flex';
            document.getElementById('whatsNewButton').style.display = 'block';

            // Hide master controls
            document.getElementsByClassName('section-master')[0].classList.add('d-none');
            document.getElementById('revealBtn').style.display = 'none';
            document.getElementById('resetBtn').style.display = 'none';

            // Hide statistics
            votesRevealed = false; // Reset voting state
            document.getElementById('statisticsSection').style.display = 'none';

            // Disconnect from current room
            if (currentRoom) {
                socket.disconnect();
                socket.connect();
            }

            currentRoom = null;
            isMaster = false;
        }

        function joinRoom() {
            let name = document.getElementById('username').value;
            let room = document.getElementById('room').value;
            isMaster = document.getElementById('isMaster').checked;

            if (name && room) {
                // Unlock audio for mobile browsers on first user interaction
                unlockAudio();

                currentRoom = room;
                userName = name;

                // Session bilgilerini kaydet
                saveSession(room, name, isMaster, selectedAvatar);

                socket.emit('joinRoom', { room: currentRoom, name: name, isMaster: isMaster, avatar: selectedAvatar });

                // Always hide/show master controls based on current role
                if (isMaster) {
                    document.getElementsByClassName('section-master')[0].classList.remove('d-none');
                    document.getElementById('revealBtn').style.display = 'block';
                    document.getElementById('resetBtn').style.display = 'block';
                } else {
                    document.getElementsByClassName('section-master')[0].classList.add('d-none');
                    document.getElementById('revealBtn').style.display = 'none';
                    document.getElementById('resetBtn').style.display = 'none';
                }

                // Update user info display
                document.getElementById('userAvatarDisplay').textContent = selectedAvatar;
                document.getElementById('userNameDisplay').textContent = name;
                document.getElementById('userRoomDisplay').textContent = `Room: ${room}`;

                document.getElementById('joinSection').style.display = 'none';
                document.getElementById('gameSection').classList.remove('d-none');

                // Hide What's New button when entering room
                document.getElementById('whatsNewButton').style.display = 'none';

            } else {
                alert('ismini ve bağlanmak istediğin odayı gir.');
            }
        }

        // Helper function to distribute users across rows evenly
        function distributeUsersToRows(users, maxPerRow = 8) {
            if (!users || !Array.isArray(users)) {
                console.error('distributeUsersToRows: invalid users array', users);
                return [];
            }

            const userCount = users.length;
            if (userCount === 0) return [];

            // Calculate number of rows needed
            const rows = Math.ceil(userCount / maxPerRow);

            // Calculate users per row (distribute evenly)
            const baseUsersPerRow = Math.floor(userCount / rows);
            const extraUsers = userCount % rows;

            const rowSizes = [];
            for (let i = 0; i < rows; i++) {
                // First 'extraUsers' rows get one extra user
                rowSizes.push(baseUsersPerRow + (i < extraUsers ? 1 : 0));
            }

            // Split users into rows
            const userRows = [];
            let currentIndex = 0;
            for (const size of rowSizes) {
                userRows.push(users.slice(currentIndex, currentIndex + size));
                currentIndex += size;
            }

            console.log(`Distributed ${userCount} users into ${userRows.length} rows:`, rowSizes);
            return userRows;
        }

        // Helper function to render user card
        function renderUserCard(user, showVoteValue = false) {
            if (!user) {
                console.error('renderUserCard called with null/undefined user');
                return '';
            }

            const breakClass = user.requestBreak ? 'has-break-request' : '';
            const questionClass = user.hasQuestion ? 'has-question' : '';
            const awayClass = user.isAway ? 'is-away' : '';
            const masterClass = user.isMaster ? 'is-master' : '';
            const masterBadge = user.isMaster ? ' 👑' : '';
            const userAvatar = user.avatar || '👤';
            const userName = user.name || 'Unknown';
            const socketId = user.socketId || '';

            let voteDisplay;
            let revealedClass = '';

            if (showVoteValue) {
                // Show actual vote values
                revealedClass = 'vote-revealed';
                if (user.isMaster) {
                    voteDisplay = '🥺';
                } else if (user.isAway) {
                    voteDisplay = '💤';
                } else if (user.vote === '☕') {
                    voteDisplay = '☕';
                } else if (user.vote !== null && user.vote !== 'null' && user.vote !== undefined) {
                    voteDisplay = String(user.vote);
                } else {
                    voteDisplay = '🥺';
                }
            } else {
                // Show vote status
                voteDisplay = user.isMaster ? 'Voted' : (user.isAway ? '💤' : (user.vote !== null && user.vote !== undefined ? 'Voted' : 'Not voted'));
            }

            const vibrateButton = (isMaster && !user.isMaster)
                ? `<button class="vibrate-btn" onclick="sendVibration('${socketId}', event)" title="Notify user">🔔</button>`
                : '';

            return `
                <div class="userCard ${(user.vote !== null && user.vote !== undefined) || user.isMaster ? 'voted' : ''} ${breakClass} ${questionClass} ${awayClass} ${masterClass}" data-socket-id="${socketId}">
                    ${vibrateButton}
                    <div class="user-card-avatar">${userAvatar}</div>
                    <h3>${userName}${masterBadge}</h3>
                    <p class="${revealedClass}">${voteDisplay}</p>
                </div>
            `;
        }

        socket.on('updateUsers', function (users) {
            // Sort users: master first, then others
            const sortedUsers = Object.values(users).sort((a, b) => {
                if (a.isMaster) return -1;
                if (b.isMaster) return 1;
                return 0;
            });

            // Distribute users to rows
            const userRows = distributeUsersToRows(sortedUsers, 8);

            let userList = '';
            userRows.forEach((row, rowIndex) => {
                userList += `<div class="user-row">`;
                row.forEach((user) => {
                    userList += renderUserCard(user, false);
                });
                userList += `</div>`;
            });

            document.getElementById("users").innerHTML = userList;

            // Only hide statistics if votes haven't been revealed yet
            if (!votesRevealed) {
                document.getElementById('statisticsSection').style.display = 'none';
            }
        });



        socket.on('updateVotes', function (users, voters, statistics) {
            console.log('updateVotes received:', users, statistics);

            try {
                // Sort users: master first, then others
                const sortedUsers = Object.values(users).sort((a, b) => {
                    if (a.isMaster) return -1;
                    if (b.isMaster) return 1;
                    return 0;
                });

                console.log('Sorted users:', sortedUsers.length);

                // Distribute users to rows
                const userRows = distributeUsersToRows(sortedUsers, 8);

                console.log('User rows:', userRows.length);

                let userList = '';
                userRows.forEach((row, rowIndex) => {
                    userList += `<div class="user-row">`;
                    row.forEach((user) => {
                        userList += renderUserCard(user, true); // Show vote values
                    });
                    userList += `</div>`;
                });

                console.log('Updating users HTML...');
                document.getElementById("users").innerHTML = userList;

                // Show statistics section and update values
                if (statistics) {
                    votesRevealed = true; // Mark votes as revealed
                    document.getElementById('statisticsSection').style.display = 'flex';
                    document.getElementById('mostCommonValue').textContent = statistics.median;
                    document.getElementById('consensusValue').textContent = statistics.consensus;
                    console.log('Statistics updated:', statistics);
                }
            } catch (error) {
                console.error('Error in updateVotes:', error);
            }
        });

        socket.on('pulseDetected', function () {
            console.log('pulseDetected');
        });

        socket.on('hideVotes', function (users) {
            // Hide votes but keep vote data (triggered when someone changes vote after reveal)
            // Sort users: master first, then others
            const sortedUsers = Object.values(users).sort((a, b) => {
                if (a.isMaster) return -1;
                if (b.isMaster) return 1;
                return 0;
            });

            // Distribute users to rows
            const userRows = distributeUsersToRows(sortedUsers, 8);

            let userList = '';
            userRows.forEach((row) => {
                userList += `<div class="user-row">`;
                row.forEach((user) => {
                    userList += renderUserCard(user, false); // Hide vote values
                });
                userList += `</div>`;
            });

            document.getElementById("users").innerHTML = userList;

            // Hide statistics section and mark votes as not revealed
            votesRevealed = false;
            document.getElementById('statisticsSection').style.display = 'none';

            // Keep vote buttons active for users who already voted
            let voteButtons = document.querySelectorAll('.vote-btn');
            voteButtons.forEach(button => {
                button.classList.remove('active');
            });

            const currentUser = users[socket.id];
            if (currentUser && currentUser.vote !== null && currentUser.vote !== 'null') {
                voteButtons.forEach(button => {
                    if (button.textContent === String(currentUser.vote)) {
                        button.classList.add('active');
                    }
                });
            }
        });

        socket.on('votesReset', function (users) {
            // Sort users: master first, then others
            const sortedUsers = Object.values(users).sort((a, b) => {
                if (a.isMaster) return -1;
                if (b.isMaster) return 1;
                return 0;
            });

            // Distribute users to rows
            const userRows = distributeUsersToRows(sortedUsers, 8);

            let userList = '';
            userRows.forEach((row) => {
                userList += `<div class="user-row">`;
                row.forEach((user) => {
                    userList += renderUserCard(user, false); // Hide vote values
                });
                userList += `</div>`;
            });

            document.getElementById("users").innerHTML = userList;

            // Hide statistics section
            votesRevealed = false; // Reset voting state
            document.getElementById('statisticsSection').style.display = 'none';
            document.getElementById('mostCommonValue').textContent = '-';
            document.getElementById('consensusValue').textContent = '-';

            let voteButtons = document.querySelectorAll('.vote-btn');
            voteButtons.forEach(button => {
                button.classList.remove('active');
            });

            // Re-activate the current user's vote button if they have voted
            const currentUser = users[socket.id];
            if (currentUser && currentUser.vote !== null && currentUser.vote !== 'null') {
                voteButtons.forEach(button => {
                    if (button.textContent === String(currentUser.vote)) {
                        button.classList.add('active');
                    }
                });
            }
        });

        // Toggle vote function - allows deselecting
        function toggleVote(e, vote) {
            // Unlock audio on first vote interaction (backup for mobile browsers)
            if (!audioUnlocked) {
                unlockAudio();
            }

            const btn = e.target;
            const isActive = btn.classList.contains('active');

            // Remove active from all vote buttons
            let voteButtons = document.querySelectorAll('.vote-btn');
            voteButtons.forEach(button => {
                button.classList.remove('active');
            });

            // Reset revealed state when voting changes
            votesRevealed = false;
            document.getElementById('statisticsSection').style.display = 'none';

            if (isActive) {
                // Deselect - send null vote
                socket.emit('vote', { vote: null, room: currentRoom });
            } else {
                // Select new vote
                btn.classList.add('active');
                socket.emit('vote', { vote: vote, room: currentRoom });
            }
        }

        function showVotes() {
            socket.emit('showVotes', currentRoom);
        }

        function resetVotes() {
            let voteButtons = document.querySelectorAll('.vote-btn');
            voteButtons.forEach(button => {
                button.classList.remove('active');
            });

            socket.emit('resetVotes', currentRoom);
        }

        // Break request toggle
        function toggleBreakRequest() {
            // Unlock audio on interaction (backup for mobile browsers)
            if (!audioUnlocked) {
                unlockAudio();
            }

            const btn = document.getElementById('breakRequestBtn');
            const isActive = btn.classList.contains('active');

            if (isActive) {
                btn.classList.remove('active');
                socket.emit('breakRequest', { room: currentRoom, requestBreak: false });
            } else {
                btn.classList.add('active');
                socket.emit('breakRequest', { room: currentRoom, requestBreak: true });
            }
        }

        // Question toggle
        function toggleQuestion() {
            // Unlock audio on interaction (backup for mobile browsers)
            if (!audioUnlocked) {
                unlockAudio();
            }

            const btn = document.getElementById('questionBtn');
            const isActive = btn.classList.contains('active');

            if (isActive) {
                btn.classList.remove('active');
                socket.emit('question', { room: currentRoom, hasQuestion: false });
            } else {
                btn.classList.add('active');
                socket.emit('question', { room: currentRoom, hasQuestion: true });
            }
        }

        // Send vibration to specific user with button feedback
        function sendVibration(targetSocketId, event) {
            const button = event.currentTarget;

            // Add sending state
            button.classList.add('sending');
            button.textContent = '✨';

            // Vibrate the target user's card on Scrum Master's screen
            const targetCard = document.querySelector(`.userCard[data-socket-id="${targetSocketId}"]`);
            if (targetCard) {
                targetCard.classList.add('vibrating');
                setTimeout(() => {
                    targetCard.classList.remove('vibrating');
                }, 500);
            }

            // Play sound for Scrum Master too
            playNotificationSound();

            // Send vibration
            socket.emit('sendVibration', { room: currentRoom, targetSocketId: targetSocketId });

            // Reset button after animation
            setTimeout(() => {
                button.classList.remove('sending');
                button.textContent = '🔔';
            }, 600);
        }

        // Initialize and unlock audio for mobile browsers
        function initializeAudio() {
            if (!notificationAudio) {
                notificationAudio = new Audio('nudge.mp3');
                notificationAudio.volume = 0.7;
                // Preload the audio
                notificationAudio.load();
            }
            return notificationAudio;
        }

        // Unlock audio on first user interaction (required for mobile browsers)
        function unlockAudio() {
            if (audioUnlocked) return;

            const audio = initializeAudio();
            // Play and immediately pause to unlock audio context
            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    audio.pause();
                    audio.currentTime = 0;
                    audioUnlocked = true;
                    console.log('Audio unlocked for mobile browser');
                }).catch(error => {
                    console.log('Audio unlock failed:', error);
                });
            }
        }

        // Play MSN Messenger nudge sound
        function playNotificationSound() {
            const audio = initializeAudio();

            // Reset audio to start
            audio.currentTime = 0;

            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.log('Audio playback failed:', error);
                    // Try to unlock audio if it failed
                    if (!audioUnlocked) {
                        console.log('Attempting to unlock audio...');
                    }
                });
            }
        }

        // Receive vibration
        socket.on('receiveVibration', function(data) {
            // Play MSN-style notification sound (always play, regardless of DOM state)
            playNotificationSound();

            const userCard = document.querySelector(`.userCard[data-socket-id="${socket.id}"]`);
            if (userCard) {
                userCard.classList.add('vibrating');

                // Remove animation class after animation completes
                setTimeout(() => {
                    userCard.classList.remove('vibrating');
                }, 500);
            }

            console.log(`Vibration received from Scrum Master!`);
        });


        // Manuel pulse mekanizması kaldırıldı
        // Socket.io'nun kendi ping/pong mekanizması yeterli

    </script>


</head>

<body>

    <!-- Theme Toggle (Fixed position, always visible) -->
    <div class="theme-toggle-container">
        <div class="theme-toggle-switch" onclick="toggleTheme()">
            <div class="theme-toggle-slider">
                <span id="themeIcon">🌙</span>
            </div>
        </div>
    </div>

    <!-- Join Section (Login Screen) -->
    <div class="join-section" id="joinSection">
        <div class="join-container">
            <div class="join-header">
                <h1>Scrum Poker</h1>
            </div>

            <div class="form-group">
                <label for="username">Your Name</label>
                <input type="text" id="username" placeholder="Enter your name" required>
            </div>

            <div class="form-group">
                <label for="room">Room Name</label>
                <input type="text" id="room" value="ecm" placeholder="Enter room name" required>
            </div>

            <div class="recommended-rooms-container">
                <label>Recommended Rooms</label>
                <div class="room-chips">
                    <button class="room-chip" onclick="selectRoom('ECM-Gryffindor')">ECM-Gryffindor</button>
                    <button class="room-chip" onclick="selectRoom('ECM-Hufflepuff')">ECM-Hufflepuff</button>
                </div>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="isMaster">
                <label for="isMaster">Join as Scrum Master</label>
            </div>

            <div class="avatar-section">
                <span class="avatar-section-label">Choose Avatar</span>
                <div class="avatar-grid">
                    <label class="avatar-option selected">
                        <input type="radio" name="avatar" value="👤" checked>
                        <span>👤</span>
                    </label>
                    <label class="avatar-option">
                        <input type="radio" name="avatar" value="👨‍💼">
                        <span>👨‍💼</span>
                    </label>
                    <label class="avatar-option">
                        <input type="radio" name="avatar" value="👩‍💻">
                        <span>👩‍💻</span>
                    </label>
                    <label class="avatar-option">
                        <input type="radio" name="avatar" value="🧑‍💻">
                        <span>🧑‍💻</span>
                    </label>
                    <label class="avatar-option">
                        <input type="radio" name="avatar" value="🧙‍♂️">
                        <span>🧙‍♂️</span>
                    </label>
                    <label class="avatar-option">
                        <input type="radio" name="avatar" value="🦸">
                        <span>🦸</span>
                    </label>
                    <label class="avatar-option">
                        <input type="radio" name="avatar" value="🐱">
                        <span>🐱</span>
                    </label>
                    <label class="avatar-option">
                        <input type="radio" name="avatar" value="🐶">
                        <span>🐶</span>
                    </label>
                    <label class="avatar-option">
                        <input type="radio" name="avatar" value="🦁">
                        <span>🦁</span>
                    </label>
                    <label class="avatar-option">
                        <input type="radio" name="avatar" value="🦊">
                        <span>🦊</span>
                    </label>
                </div>
            </div>

            <button class="join-button" onclick="joinRoom()">Join Room</button>
        </div>
    </div>

    <!-- What's New Button -->
    <button class="whats-new-button" id="whatsNewButton" onclick="toggleWhatsNew()">
        ✨ What's New?
    </button>

    <!-- Feedback Button -->
    <button class="feedback-button" id="feedbackButton" onclick="toggleFeedback()">
        💬 Feedback
    </button>

    <!-- Feedback Modal -->
    <div class="feedback-modal" id="feedbackModal">
        <div class="feedback-modal-content">
            <div class="feedback-modal-header">
                <h2 class="feedback-title">Leave feedback</h2>
                <button class="close-modal" onclick="toggleFeedback()">&times;</button>
            </div>
            <p class="feedback-description">Thank you for using Scrum Poker. We are always looking to improve the app, so please leave us some feedback or suggestions to make your experience better.</p>
            <form id="feedbackForm" onsubmit="submitFeedback(event)">
                <div class="form-group-feedback">
                    <label for="rating">How would you rate your experience?</label>
                    <div class="rating-stars">
                        <input type="radio" name="rating" id="star5" value="5" required>
                        <label for="star5" class="star">★</label>
                        <input type="radio" name="rating" id="star4" value="4">
                        <label for="star4" class="star">★</label>
                        <input type="radio" name="rating" id="star3" value="3">
                        <label for="star3" class="star">★</label>
                        <input type="radio" name="rating" id="star2" value="2">
                        <label for="star2" class="star">★</label>
                        <input type="radio" name="rating" id="star1" value="1">
                        <label for="star1" class="star">★</label>
                    </div>
                </div>
                <div class="form-group-feedback">
                    <label for="feedbackEmail">Email (optional)</label>
                    <input type="email" id="feedbackEmail" placeholder="your.email@example.com">
                </div>
                <div class="form-group-feedback">
                    <label for="feedbackMessage">Tell us what you think</label>
                    <textarea id="feedbackMessage" rows="5" placeholder="Share your thoughts, suggestions, or report issues..." required></textarea>
                </div>
                <button type="submit" id="feedbackSubmitBtn" class="feedback-submit-btn">Send Feedback</button>
            </form>
            <div id="feedbackSuccess" class="feedback-success" style="display: none;">
                <p>✅ Thank you for your feedback! We appreciate your input.</p>
            </div>
        </div>
    </div>

    <!-- What's New Modal -->
    <div class="whats-new-modal" id="whatsNewModal">
        <div class="whats-new-modal-content">
            <div class="whats-new-modal-header">
                <h2 class="whats-new-title">What's New? ✨</h2>
                <button class="close-modal" onclick="toggleWhatsNew()">&times;</button>
            </div>
            <ul class="whats-new-list">
                <li>🎨 <strong>Complete UI/UX Redesign:</strong> Modern, clean interface with smooth animations and premium button interactions</li>
                <li>🌓 <strong>Enhanced Dark Mode:</strong> Elegant theme toggle with smooth transitions between light and dark modes</li>
                <li>👤 <strong>Custom Avatars:</strong> Choose from 10 unique avatars that display throughout your session</li>
                <li>⏰ <strong>6-Hour Session Persistence:</strong> Your session data is saved for 6 hours - close your browser and come back anytime</li>
                <li>🔄 <strong>5-Minute Reconnection Grace:</strong> If you disconnect temporarily, you have 5 minutes to reconnect without losing your spot</li>
                <li>💤 <strong>Away Status Indicator:</strong> Disconnected users are marked as "Away" with a sleep emoji and dashed border until they reconnect or are removed</li>
                <li>🏠 <strong>Recommended Rooms:</strong> Quick access to suggested room names on the login screen for faster joining</li>
                <li>🔙 <strong>Quick Return to Login:</strong> Click on your user info box in the lobby to instantly return to the login screen</li>
                <li>☕ <strong>Break & Question Indicators:</strong> Subtle emoji badges appear on user avatars when requesting breaks or asking questions</li>
                <li>🎯 <strong>Flexible Voting:</strong> Change or deselect your vote anytime - when votes are revealed and you change your vote, only the votes are hidden (not deleted)</li>
                <li>🔄 <strong>Restart Anytime:</strong> Scrum Masters can restart voting at any time, even without revealing votes first</li>
                <li>📊 <strong>Voting Statistics:</strong> Automatic calculation of Most Common vote and Consensus percentage when votes are revealed (excludes Scrum Master votes)</li>
                <li>🔔 <strong>MSN Messenger-Style Notifications:</strong> Scrum Masters can send instant vibration alerts to team members with sound effects and visual feedback</li>
                <li>✨ <strong>Premium Button Interactions:</strong> Satisfying haptic-like feedback animations with color transitions and state changes</li>
                <li>📈 <strong>Prominent Vote Display:</strong> When votes are revealed, they appear large and clear for easy consensus building</li>
                <li>🎪 <strong>Long Name Support:</strong> User names of any length display elegantly without truncation throughout the interface</li>
                <li>👥 <strong>Visual Grouping for Large Teams:</strong> When 9+ users join, cards are arranged in visually distinct rows for better organization</li>
            </ul>
        </div>
    </div>

    <!-- Game Section (Lobby Screen) -->
    <div id="gameSection" class="game-section d-none">
        <div class="container">
            <div class="header-area">
                <div class="user-info-section" onclick="returnToLogin()" title="Click to return to login screen">
                    <div class="user-avatar-display" id="userAvatarDisplay">👤</div>
                    <div class="user-details-display">
                        <h2 id="userNameDisplay">User</h2>
                        <p id="userRoomDisplay">Room: -</p>
                    </div>
                </div>

                <div class="page-title">
                    <h1>Scrum Poker</h1>
                </div>
            </div>

            <div class="divider"></div>

            <div class="voting-section">
                <div class="voting-controls">
                    <div class="vote-buttons">
                        <button class="vote-btn" onclick="toggleVote(event, 0)">0</button>
                        <button class="vote-btn" onclick="toggleVote(event, 1)">1</button>
                        <button class="vote-btn" onclick="toggleVote(event, 2)">2</button>
                        <button class="vote-btn" onclick="toggleVote(event, 3)">3</button>
                        <button class="vote-btn" onclick="toggleVote(event, 5)">5</button>
                        <button class="vote-btn" onclick="toggleVote(event, 8)">8</button>
                        <button class="vote-btn" onclick="toggleVote(event, 13)">13</button>
                        <button class="vote-btn" onclick="toggleVote(event, 21)">21</button>
                        <button class="vote-btn" onclick="toggleVote(event, 40)">40</button>
                        <button class="vote-btn" onclick="toggleVote(event, '☕')">☕</button>
                    </div>
                    <div class="request-buttons">
                        <button id="breakRequestBtn" class="request-btn" onclick="toggleBreakRequest()">
                            ☕ Request Break
                        </button>
                        <button id="questionBtn" class="request-btn" onclick="toggleQuestion()">
                            ❓ Question
                        </button>
                    </div>
                </div>

                <!-- Statistics Section (shown only when votes are revealed) -->
                <div id="statisticsSection" class="statistics-section" style="display: none;">
                    <div class="stat-card">
                        <div class="stat-label">🎯 Most Common</div>
                        <div class="stat-value" id="mostCommonValue">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">🤝 Consensus</div>
                        <div class="stat-value" id="consensusValue">-</div>
                    </div>
                </div>
            </div>

            <div class="divider"></div>

            <div class="section-master master-controls d-none">
                <button
                    id="revealBtn"
                    class="master-btn"
                    onclick="showVotes()"
                    style="display: none;"
                >Reveal Votes</button>

                <button
                    id="resetBtn"
                    class="master-btn danger"
                    onclick="resetVotes()"
                    style="display: none;"
                >Restart</button>
            </div>

            <div id="userContainer">
                <div class="users-grid" id="users"></div>
            </div>
        </div>
    </div>

</body>

</html>